E2EE prerequisites
==================

E2EE developers are highly encouraged to read this section first before implementing any E2EE flow,
as these procedures are required for the E2EE flows to run correctly and securely. Additionally,
some terminologies used henceforth are defined in :ref:`dev-guide/kms-e2e-crypto-services:end-to-end cryptographic services`.


Before developing your app
--------------------------

The E2EE mobile SDK, provided by Klavis Kripta, is built on Flutter version 1.17.0. It is highly
recommended to develop your frontend on a Flutter version 1.17.0 or higher. You can get the E2EE Flutter mobile SDK at
https://dev.klaviskripta.com/klavis-kripta-inovasi/kripta-key-documentation/-/merge_requests/19 . 

.. todo::

    TODO: Determine the exact version of Flutter that is used to build the SDK.

While building the frontend, the minimum required Android version must be set to API level 25 (Android 7.1).


E2EE preparation
----------------

Before performing any E2EE functionality, the backend must generate and store several RSA key pairs, using
the ``appstored/keypair/generate`` API endpoint. These are the transport keys, which will be used to secure
the communication between the frontend, the backend, and Kripta Key --- see :ref:`e2ee-dev-guide/e2ee-prerequisites:e2ee pre-authentication`
for details on how these key pairs are used. For increased security, these keys may be regenerated regularly.

.. note::

    We recommend generating 10 to 30 RSA key pairs with 2048-bit key length, regenerating a fresh set of key pairs once
    every few months.

.. important::

    In order to prepare the transport keys, the Kripta Key admin must have generated a wrapping key.


Backend authentication
----------------------

The first flow that must be done by the frontend is authenticating the backend --- that is, ensuring that the frontend
is communicating with the correct backend. This authentication is done cryptographically, utilizing the backend
certificate generated by Kripta Key. The frontend developer must pin this certificate to the app.

.. note::

    We recommend performing backend authentication each time the frontend initially loads --- i.e., as part of frontend
    initialization.

.. important::

    To create the backend certificate, the Kripta Key admin must have generated a key pair and a certificate associated
    with the key pair.

The following are the steps to perform backend authentication:

#.  Frontend calls ``rnd`` from the SDK, generating a nonce. We recommend 10 random bytes for the nonce.
#.  Frontend caches the nonce.
#.  Frontend calls ``encryptRSA`` from the SDK, encrypting the nonce using the :term:`pinned certificate`.
#.  Frontend requests backend authentication, sending the encrypted nonce.
#.  Backend calls ``decrypt`` from Kripta Key API, decrypting the encrypted nonce using the certificate's private key.
#.  Backend calls ``sign`` from Kripta Key API, signing the nonce using the certificate's private key.
#.  Backend sends back the signature to the frontend.
#.  Frontend calls ``verifyRSA`` from the SDK, verifying the signature with the nonce using the pinned certificate.
#.  If signature is valid, then the frontend has connected to the correct backend. Otherwise, stop.

.. uml::

    @startuml

    skinparam maxMessageSize 240

    box "Frontend" #FFD700
        participant "User" as user
        participant "Mobile App" as client
        participant "E2EE Mobile SDK" as clientlib
    end box
    box "Backend"
        participant "App Server" as appserver
        participant "Kripta Key" as kk
    end box

    == Backend Server Authentication ==

    autonumber
    user -> client : start app
    client -> clientlib : call ""rnd"" to generate 10 bytes nonce
    clientlib -> client : nonce
    client -> client : cache nonce
    client -> clientlib : call ""encryptRSA"", passing in nonce and pinned certificate
    clientlib -> client : RSA encrypted nonce
    client -> appserver : request for server authentication, send encrypted nonce
    appserver -> kk : decrypt the nonce using private key of server certificate by calling API ""decrypt""
    kk -> appserver : clear nonce
    appserver -> kk : sign the nonce using private key of server certificate by calling API ""sign""
    kk -> appserver : signature from nonce
    appserver -> client : signature from nonce
    client -> clientlib : call ""verifyRSA"" passing in nonce, signature and pinned certificate
    clientlib -> client : verification result
    client -> client : if signature is not verified, stop

    @enduml


E2EE pre-authentication
-----------------------

In this step, the frontend and the backend establish a secure channel by using a transport key, previously prepared
during :ref:`e2ee-dev-guide/e2ee-prerequisites:e2ee preparation`. As such, this flow **MUST** run recently
prior to executing any E2EE flow.

.. note::

    We recommend either running this flow right before executing the intended E2EE flow, or rerunning this flow after
    a certain amount of time has passed since the last time this flow was executed --- e.g. 5 minutes.

The following are the steps to perform E2EE pre-authentication:

#.  Frontend requests for the transport key and other parameters from the backend.
#.  Backend chooses a key pair at random from the pool application-stored key pairs (as specified in :ref:`e2ee-dev-guide/e2ee-prerequisites:e2ee preparation`).
#.  Backend generates an :term:`OAEP label` at random. We recommend a length of 64 bytes.
#.  Backend generates an E2EE session cache entry with a unique session ID.
#.  Backend caches the wrapped transport private key and the OAEP label.
#.  Backend sends back the transport public key, OAEP label, and session ID to the frontend.

.. uml::

    @startuml

    skinparam maxMessageSize 240

    box "Frontend" #FFD700
        participant "User" as user
        participant "Mobile App" as client
        participant "E2EE Mobile SDK" as clientlib
    end box
    box "Backend"
        participant "App Server" as appserver
        participant "Kripta Key" as kk
    end box

    == E2EE Pre-Authentication ==

    autonumber
    user -> client : start app
    client -> appserver : request for transport key and other params
    appserver -> appserver : generate an E2EE session cache entry with a randomly chosen key pair, randomly generated OAEP label, and a unique session ID
    appserver -> client : return transport public key, OAEP label and session ID

    @enduml

.. note::

    For the random selection process, it is highly recommended to either use a secure random number generator, or use
    Kripta Key's ``rng`` API endpoint to generate randomness.

.. warning::

    It is important to note that the backend **MUST** implement its own caching mechanism for the key pair, OAEP label, and
    session ID corresponding to this particular E2EE session. On top of that, it **MUST** implement a timeout for the cache
    entries. We recommend invalidating cache entries 5 minutes after their creation.
