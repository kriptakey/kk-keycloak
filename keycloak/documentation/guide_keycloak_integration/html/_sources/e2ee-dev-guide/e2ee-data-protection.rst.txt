E2EE for data protection
========================

It is important to secure user data transmitted from the backend to the frontend and vice-versa, especially if the user
data is personally identifiable. The data protection flows are intended to protect user data in transit.

.. important::

    The Kripta Key admin **MUST** have generated a specific AES key to encrypt the data. This is called
    the permanent key.


Data protection from client to server
-------------------------------------

.. important::

    :ref:`e2ee-dev-guide/e2ee-prerequisites:e2ee pre-authentication` must have been done prior to executing this flow.

This flow is used to protect user data sent from the frontend to the backend. The user data is protected in transit
using the transport public key chosen randomly during pre-authentication, and at rest using the data encryption key.

The following are the steps to perform E2EE data protection from frontend to backend:

#.  Frontend calls ``e2eeEncrypt`` from the SDK, encrypting the data with the transport public key
    and OAEP label established in pre-authentication.
#.  Frontend sends the encrypted data block and its metadata, and the session ID to the backend.
#.  Backend fetches the OAEP label and wrapped transport private key from the session cache using the session ID.
#.  Backend calls ``e2ee/reencryptFromSessionKeyToPermanentKey`` from Kripta Key API, reencrypting the data using the
    wrapped transport private key and the permanent key.
#.  Backend stores the encrypted data into its database.
#.  Backend sends the outcome of the operation to the frontend.

.. uml::

    @startuml

    skinparam maxMessageSize 240

    box "Frontend" #FFD700
       participant "User" as user
       participant "Mobile App" as client
       participant "E2EE Mobile SDK" as clientlib
    end box
    box "Backend"
       participant "App Server" as appserver
       participant "Kripta Key" as kk
    end box

    == E2EE for Data Protection (Client to Server) ==

    autonumber
    user -> client : input data
    client -> clientlib : call ""e2eeEncrypt"", passing in data, transport public key and OAEP label
    clientlib -> client : return encrypted data block (EDB) and metadata
    client -> appserver : send EDB and metadata
    appserver -> appserver : fetch OAEP label and wrapped transport private key from E2EE session cache by using the session ID
    appserver -> kk : call ""e2ee/reencryptFromSessionKeyToPermanentKey"", passing in wrapping key ID, wrapped transport private key, OAEP label, and EDB
    kk -> appserver : reencrypted data
    appserver -> appserver : store reencrypted data to database
    appserver -> client : status

    @enduml


Client key establishment protocol
---------------------------------

Before encrypted data can flow from the backend to the frontend, the frontend must first receive an AES key from Kripta
Key. This AES key, called the client key, will be secured in transit using an RSA public key that is generated by the
frontend, and at rest by being wrapped using a Kripta Key-stored key that has been prepared beforehand.

.. important::

    The Kripta Key admin **MUST** have generated the Kripta Key-stored key to wrap the client key.

These steps establish the client key that secures user data between the frontend, the backend, and Kripta Key. This key
is ephemeral --- each time the frontend starts, a new client key will be created as the old one is discarded.

.. note::

    If :term:`device binding` is enabled (see :ref:`e2ee-dev-guide/e2ee-passwordless-auth:device registration`),
    then this flow only needs to run once, during device registration. Otherwise, this flow **MUST** run
    every time the frontend bootstraps.

The following are the steps to establish a client key between the frontend and the backend:

#.  Frontend calls ``createKeyPairInSecureStore`` from the SDK, creating a key pair that is stored securely by the
    device's operating system.
#.  Frontend requests a client key, sending the generated public key to the backend.
#.  Backend calls ``appstored/key/generate`` from Kripta Key API, generating a payload containing the client key,
    which is encrypted using the frontend's public key. Do ensure that the endpoint is called with the appropriate
    operating system parameter.
#.  Backend sends the payload to the frontend.
#.  Frontend calls ``updateClientKeyToSecureStorage`` from the SDK, decrypting the payload with its private key.
    The decrypted payload is stored in secure storage.

.. uml::

    @startuml

    skinparam maxMessageSize 240

    box "Frontend" #FFD700
        participant "User" as user
        participant "Mobile App" as client
        participant "E2EE Mobile SDK" as clientlib
    end box
    box "Backend"
        participant "App Server" as appserver
        participant "Kripta Key" as kk
    end box

    == Client Key Establishment Protocol ==

    autonumber
    user -> client : start app
    client -> clientlib : call ""createKeyPairInSecureStore""
    clientlib -> client : return public key from secure storage
    client -> appserver : request ephemeral client key, passing secure store public key
    appserver -> kk : call ""appstored/key/generate"" with wrapping method ""android"" for Android or ""iOS""  for iOS
    kk -> appserver : wrapped key payload
    appserver -> client : wrapped key payload
    client -> clientlib : call ""updateClientKeyToSecureStorage"" passing in wrapped key payload
    clientlib -> client : status

    @enduml

.. note::

    The payload consists of the client key **AND** the client key wrapped using the prepared Kripta Key-stored key.
    This way, neither the backend nor Kripta Key needs to store the client key --- that task is delegated
    to the frontend.


Data protection from server to client
-------------------------------------

.. important::

    :ref:`e2ee-dev-guide/e2ee-data-protection:client key establishment protocol` must have been done
    prior to executing this flow.

After the client key has been successfully established, this flow may execute as many times as necessary.

The following are the steps to perform E2EE data protection from backend to frontend:

#.  Frontend calls ``getWrappedClientKey`` from the SDK, fetching the wrapped client key from secure storage,
    a nonce (additional authenticated data), and metadata.
#.  Frontend caches the nonce.
#.  Frontend sends the wrapped client key and the metadata to the backend.
#.  Backend fetches the encrypted data from its database.
#.  Backend calls ``e2ee/reencryptFromPermanentKeyToSessionKey`` from Kripta Key API, reencrypting the stored data
    using the permanent key and the wrapped client key.
#.  Backend sends the encrypted data to the frontend.
#.  Frontend calls ``e2eeDecrypt`` from the SDK, decrypting the data and using the cached nonce to verify
    that it has not been tampered with.

.. uml::

    @startuml

    skinparam maxMessageSize 240

    box "Frontend" #FFD700
        participant "User" as user
        participant "Mobile App" as client
        participant "E2EE Mobile SDK" as clientlib
    end box
    box "Backend"
        participant "App Server" as appserver
        participant "Kripta Key" as kk
    end box

    == E2EE for Data Protection (Server to Client) ==

    autonumber
    user -> client : fetch data
    client -> clientlib : call ""getWrappedClientKey""
    clientlib -> client : wrapped client key, nonce, and metadata
    client -> client : cache nonce
    client -> appserver : send wrapped client key and metadata
    appserver -> appserver : fetch encrypted data from database
    appserver -> kk : call ""e2ee/reencryptFromPermanentKeyToSessionKey"", passing in permanent key ID, encrypted data, wrapped client key and metadata
    kk -> appserver : encrypted data block (EDB)
    appserver -> client : EDB
    client -> clientlib: call ""e2eeDecrypt"", passing in EDB and nonce (as AAD)
    clientlib -> client : plaintext

    @enduml
